
### 进程篇
#### 进程环境
1. exit会调用终止处理函数和做io清理工作，缓存中的所有数据都会刷到盘中，然后再进入内核；_exit和_Exit直接进入内核，缓存中的数据可能丢失。
2. atexit函数可以注册终止处理函数，这些函数将由exit函数调用，调用顺序和登记顺序相反。
3. 内核使程序执行的唯一方法是调用exec函数。
4. 每个程序都会接收到一张环境表（字符指针数组），extern char **environ;(environ为全局变量)；获取环境参数也可以通过getenv函数。
5. malloc申请空间不初始化，calloc申请对象空间并且初始化为0；底层都是调用的sbrk(2)系统调用。
6. setjump和longjump可以在深度调用栈中直接返回到上层，而不是每一层处理return。
7. 每个进程资源都有限制，可以通过getrlimit和setrlimit设置和获取。

#### 进程控制
1. ID为0的进程为调度进程，也叫交换进程；ID为1的为init进程，它是一个普通用户进程，但是以超级用户特权运行。
2. 调用fork函数，父进程返回的是子进程的pid，子进程返回的是0.
3. 调用fork函数，父进程和子进程共用一个文件表项，共用偏移量，所以子进程读写会影响父进程偏移量。如果是两个独立进程分别打开文件，那么他们有独立的文件表项，但是指向同一个v节点。
4. 子进程正常或者异常终止时，内核就向其父进程发送SIGCHLD信号。
5. wait会阻塞，waitpid有选项可以控制不阻塞。
6. exec函数并不创建新进程，而只是用磁盘中的一个新程序替换当前进程的正文段，数据段，堆段和堆栈，所以前后进程ID并未改变。
7. setuid用来修改用户id，setgid用来修改组id（这两个函数也有权限限制）。


#### 进程关系
1. shell login过程
    - 1). 将当前工作目录更改为该用户的起始目录（chdir）。
    - 2). 调用chown更改该终端的所有权，使登录用户成为他的所有者。（刚建立链接时所有者是超级用户）
    3. 将对该终端设备的访问权限改变成“用户读和写”
    4. 调用setgid及initgroups设置进程的组id
    5. 用login得到的所有信息初始化环境：起始目录（HOME），shell（SHELL），用户名（USER和LOGNAME）以及一个系统默认路径
    6. login进程更改为登录用户的用户id（setuid）并调用该用户的登录shell。




